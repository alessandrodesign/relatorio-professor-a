{"version":3,"file":"public\\assets\\ts\\ApiRequest\\ApiRequestStrategy.js","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACAA,kCAAkC;AAC3B,MAAe,kBAAkB;IAAxC;QACc,UAAK,GAAkB,IAAI,CAAC;QAC5B,sBAAiB,GAAkB,IAAI,CAAC;IAmCtD,CAAC;IAjCG,sDAAsD;IAC/C,YAAY,CAAC,KAAa;QAC7B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,QAAQ,CAAC,MAAM,GAAG,SAAS,KAAK,UAAU,CAAC;IAC/C,CAAC;IAED,yBAAyB;IAClB,eAAe,CAAC,YAAoB;QACvC,IAAI,CAAC,iBAAiB,GAAG,YAAY,CAAC;IAC1C,CAAC;IAED,kGAAkG;IACxF,UAAU,CAAC,aAAsC,EAAE,OAAgB,IAAI;QAC7E,MAAM,OAAO,qBAAgC,CAAC,aAAa,IAAI,EAAE,CAAC,CAAE,CAAC;QACrE,IAAI,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;YACrB,OAAO,CAAC,eAAe,CAAC,GAAG,UAAU,IAAI,CAAC,KAAK,EAAE,CAAC;QACtD,CAAC;QAED,OAAO,CAAC,kBAAkB,CAAC,GAAG,gBAAgB,CAAC;QAE/C,OAAO,OAAO,CAAC;IACnB,CAAC;CAYJ","sources":["webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./public/assets/ts/ApiRequest/ApiRequestStrategy.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export interface RequestOptions {\r\n    headers?: Record<string, string>;\r\n    auth?: boolean;       // true por padrão; se false, não adiciona o Authorization\r\n    isMultipart?: boolean; // se true, indica que será enviado FormData para upload\r\n}\r\n\r\n// Classe abstrata pai da Strategy\r\nexport abstract class ApiRequestStrategy {\r\n    protected token: string | null = null;\r\n    protected refreshTokenValue: string | null = null;\r\n\r\n    // Define o token e, opcionalmente, registra em cookie\r\n    public setAuthToken(token: string): void {\r\n        this.token = token;\r\n        document.cookie = `token=${token}; path=/`;\r\n    }\r\n\r\n    // Define o refresh token\r\n    public setRefreshToken(refreshToken: string): void {\r\n        this.refreshTokenValue = refreshToken;\r\n    }\r\n\r\n    // Monta os headers: junta headers customizados e, se auth=true e token existir, adiciona o Bearer\r\n    protected getHeaders(customHeaders?: Record<string, string>, auth: boolean = true): Record<string, string> {\r\n        const headers: Record<string, string> = { ...(customHeaders || {}) };\r\n        if (auth && this.token) {\r\n            headers['Authorization'] = `Bearer ${this.token}`;\r\n        }\r\n\r\n        headers['X-Requested-With'] = 'XMLHttpRequest';\r\n\r\n        return headers;\r\n    }\r\n\r\n    // Métodos abstratos para serem implementados pelas strategies\r\n    abstract get(url: string, options?: RequestOptions): Promise<any>;\r\n    abstract post(url: string, data: any, options?: RequestOptions): Promise<any>;\r\n    abstract put(url: string, data: any, options?: RequestOptions): Promise<any>;\r\n    abstract patch(url: string, data: any, options?: RequestOptions): Promise<any>;\r\n    abstract delete(url: string, options?: RequestOptions): Promise<any>;\r\n    abstract login(url: string, credentials: any, options?: RequestOptions): Promise<any>;\r\n\r\n    // Cada strategy deve implementar sua lógica de refresh token\r\n    protected abstract refreshTokenRequest(): Promise<any>;\r\n}\r\n"],"names":[],"sourceRoot":""}